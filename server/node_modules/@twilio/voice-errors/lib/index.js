'use strict';

/**
 * @typedef {object} ErrorClassSpec
 * @property {number} code - a two-digit prefix
 * @property {string} class - the name of the error class
 * @property {Array<ErrorSubclassSpec>} subclasses - a list of error subclasses
 */

/**
 * @typedef {object} ErrorSubclassSpec
 * @property {number} code - a single digit
 * @property {string} class - the name of the error subclass
 * @property {Array<ErrorSpec>} errors - a list of errors
 */

/**
 * @typedef {object} ErrorSpec
 * @property {number} code - a two-digit suffix
 * @property {string} name - name of the class for the error
 * @property {string} description - a description of the error
 * @property {string} explanation - an explanation of the error
 * @property {Array<string>} causes - a list of possible causes
 * @property {Array<string>} solutions - a list of possible solutions
 */

/**
 * Create an anchor for an {@link ErrorSpec}.
 * @param {number} code - a three-digit code
 * @param {ErrorSpec} errorSpec
 * @returns {string}
 */
function createErrorSpecAnchor(code, errorSpec) {
  return `${code}${two(errorSpec.code)}-${errorSpec.description.replace(/[^a-zA-Z]/g, '-').toLowerCase()}`;
}

/**
 * Create an anchor for an {@link ErrorSubclassSpec}.
 * @param {number} code - a two-digit code
 * @param {ErrorSubclassSpec} errorSubclassSpec
 * @returns {string}
 */
function createErrorSubclassSpecAnchor(code, errorSubclassSpec) {
  return `${code}${errorSubclassSpec.code}XX-${errorSubclassSpec.class.replace(/[^a-zA-Z]/g, '-').toLowerCase()}-errors`;
}

/**
 * Create a table of contents.
 * @param {number} code - a two-digit prefix
 * @param {Array<ErrorSubclassSpec>} errorSubclassSpecs
 * @returns {string} markdown
 */
function createToC(code, errorSubclassSpecs) {
  return errorSubclassSpecs.map(errorSubclassSpec => {
    return `\n * [${code}${errorSubclassSpec.code}XX: ${errorSubclassSpec.class} Errors](#${createErrorSubclassSpecAnchor(code, errorSubclassSpec)})` +
      createSubToC(code * 10 + errorSubclassSpec.code, errorSubclassSpec.errors);
  }).join('');
}

/**
 * Create a sub-level in the table of a contents.
 * @param {number} code - a three-digit prefix
 * @param {Array<ErrorSpec>} errorSpecs
 * @returns {string} markdown
 */
function createSubToC(code, errorSpecs) {
  return errorSpecs.map(errorSpec => {
    return `\n   * [${code}${two(errorSpec.code)}: ${errorSpec.description}](#${createErrorSpecAnchor(code, errorSpec)})`;
  }).join('');
}

/**
 * Read an {@link ErrorClassSpec} from a JSON file.
 * @param {string} filepath
 * @returns {ErrorClassSpec}
 * @throws {TypeError}
 */
function readErrorClassSpec(filepath) {
  const errorClassSpec = require(filepath);

  if (typeof errorClassSpec !== 'object') {
    throw new TypeError('An ErrorClassSpec must be an object');
  }

  const klass = errorClassSpec.class;
  if (typeof klass !== 'string') {
    throw new TypeError('An ErrorClassSpec must specify a class string');
  }

  const code = errorClassSpec.code;
  if (typeof code !== 'number' || !Number.isInteger(code) || code < 10 || code > 99) {
    throw new TypeError('An ErrorClassSpec must specify a two-digit code');
  }

  const subclasses = errorClassSpec.subclasses || [];
  if (!Array.isArray(subclasses)) {
    throw new TypeError('An ErrorClassSpec must specify an Array of ErrorSubclassSpecs');
  }

  return {
    code: code,
    class: klass,
    subclasses: readErrorSubclassSpecs(subclasses)
  };
}

/**
 * Read {@link ErrorSubclassSpec}s.
 * @param {Array<*>} errorSubclassSpecs
 * @returns {Array<ErrorSubclassSpec>}
 * @throws {TypeError}
 */
function readErrorSubclassSpecs(errorSubclassSpecs) {
  return errorSubclassSpecs.reduce((accumulator, errorSubclassSpec) => {
    var lastCode = accumulator[0];
    const errorSubclassSpecs = accumulator[1];

    if (typeof errorSubclassSpec !== 'object') {
      throw new TypeError('An ErrorSubclassSpec must be an object');
    }

    errorSubclassSpec = readErrorSubclassSpec(errorSubclassSpec, lastCode);

    return [
      errorSubclassSpec.code,
      errorSubclassSpecs.concat([errorSubclassSpec])
    ];
  }, [-1, []])[1];
}

/**
 * Read an {@link ErrorSubclassSpec}.
 * @param {object} errorSubclassSpec
 * @param {number} [lastCode=-1]
 * @returns {ErrorSubclassSpec}
 * @throws {TypeError}
 */
function readErrorSubclassSpec(errorSubclassSpec, lastCode) {
  lastCode = typeof lastCode === 'number' ? lastCode : -1;

  const klass = errorSubclassSpec.class;
  if (typeof klass !== 'string') {
    throw new TypeError('An ErrorSubclassSpec must specify a class string');
  }

  var code = errorSubclassSpec.code;
  if (typeof code === 'number') {
    if (typeof code !== 'number' || !Number.isInteger(code) || code < 0 || code > 9) {
      throw new TypeError('An ErrorSubclassSpec must specify a single-digit code');
    } else if (code <= lastCode) {
      throw new TypeError(`The ${JSON.stringify(klass)} ErrorSubclassSpec must specify a single-digit code greater than ${lastCode}`);
    }
  } else {
    code = lastCode + 1;
  }

  const errors = errorSubclassSpec.errors || [];
  if (!Array.isArray(errors)) {
    throw new TypeError('An ErrorSubclassSpec must specify an Array of ErrorSpecs');
  }

  return {
    code: code,
    class: klass,
    errors: readErrorSpecs(errors)
  };
}

/**
 * Read {@link ErrorSpec}s.
 * @param {Array<*>} errorSpecs
 * @returns {Array<ErrorSpec>}
 * @throws {TypeError}
 */
function readErrorSpecs(errorSpecs) {
  return errorSpecs.reduce((accumulator, errorSpec) => {
    var lastCode = accumulator[0];
    const errorSpecs = accumulator[1];

    if (typeof errorSpec !== 'object') {
      throw new TypeError('An ErrorSpec must be an object');
    }

    errorSpec = readErrorSpec(errorSpec, lastCode);

    return [
      errorSpec.code,
      errorSpecs.concat([errorSpec])
    ];
  }, [-1, []])[1];
}

/**
 * Read an {@link ErrorSpec}.
 * @param {object} errorSpec
 * @returns {ErrorSpec}
 * @throws {TypeError}
 */
function readErrorSpec(errorSpec, lastCode) {
  lastCode = typeof lastCode === 'number' ? lastCode : -1;

  const description = errorSpec.description;
  if (typeof description !== 'string') {
    throw new TypeError('An ErrorSpec must specify a description string');
  }

  const explanation = errorSpec.explanation;
  if (typeof explanation !== 'string') {
    throw new TypeError('An ErrorSpec must specify an explanation string');
  }

  var code = errorSpec.code;
  if (typeof code === 'number') {
    if (typeof code !== 'number' || !Number.isInteger(code) || code < 0 || code > 99) {
      throw new TypeError('An ErrorSpec must specify a two-digit code');
    } else if (code <= lastCode) {
      throw new TypeError(`The ${JSON.stringify(description)} ErrorSpec must specify a two-digit code greater than ${lastCode}`);
    }
  } else {
    code = lastCode + 1;
  }

  const causes = errorSpec.causes || [];
  causes.forEach(cause => {
    if (typeof cause !== 'string') {
      throw new TypeError('An ErrorSpec cause must be a string');
    }
  });

  const solutions = errorSpec.solutions || [];
  solutions.forEach(solutions => {
    if (typeof solutions !== 'string') {
      throw new TypeError('An ErrorSpec solution must be a string');
    }
  });

  const name = errorSpec.name;
  if (typeof name !== 'string' || name === '') {
    throw new TypeError('An ErrorSpec name must be a non-empty string');
  }

  return {
    code: code,
    name: name,
    description: description,
    explanation: explanation,
    causes: causes,
    solutions: solutions
  };
}

/**
 * Pad a nonnegative integer to two digits.
 * @param {number} number
 * @returns {string}
 * @throws {TypeError} 
 */
function two(number) {
  if (number > 99) {
    throw new TypeError('Number to pad to two digits must be less than 100');
  } else if (number < 0) {
    throw new TypeError('Number to pad to two digits must be nonnegative');
  } else if (number < 10) {
    return '0' + number;
  }
  return String(number);
}

exports.createErrorSpecAnchor = createErrorSpecAnchor;
exports.createErrorSubclassSpecAnchor = createErrorSubclassSpecAnchor;
exports.createToC = createToC;
exports.readErrorClassSpec = readErrorClassSpec;
exports.two = two;
