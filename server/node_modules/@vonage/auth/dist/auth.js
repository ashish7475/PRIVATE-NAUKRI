"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const jwt_1 = require("@vonage/jwt");
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const types_1 = require("./types");
const debug_1 = __importDefault(require("debug"));
const log = (0, debug_1.default)('vonage:auth');
class Auth {
    apiKey;
    apiSecret;
    privateKey;
    applicationId;
    signature;
    constructor(opts) {
        this.apiKey = opts?.apiKey || '';
        this.apiSecret = opts?.apiSecret || '';
        this.signature = opts?.signature || null;
        this.applicationId = opts?.applicationId || null;
        if (opts?.privateKey) {
            if ((0, fs_1.existsSync)(opts.privateKey)) {
                opts.privateKey = (0, fs_1.readFileSync)(opts.privateKey).toString();
            }
            if (opts.privateKey instanceof Buffer) {
                this.privateKey = opts.privateKey.toString();
            }
            else {
                this.privateKey = opts.privateKey;
            }
        }
    }
    getQueryParams = async (params) => {
        return { api_key: this.apiKey, api_secret: this.apiSecret, ...params };
    };
    createBasicHeader = async () => {
        log('Creating basic auth header');
        const buf = Buffer.from(`${this.apiKey}:${this.apiSecret}`);
        return 'Basic ' + buf.toString('base64');
    };
    createBearerHeader = async () => {
        log('Creating bearer header');
        return 'Bearer ' + (0, jwt_1.tokenGenerate)(this.applicationId, this.privateKey);
    };
    createSignatureHash = async (params) => {
        log('Creating signature hash');
        const returnParams = Object.assign({ api_key: this.apiKey }, params);
        returnParams.timestamp = Math.floor(Date.now() / 1000).toString();
        const keys = Object.keys(returnParams);
        const stringifiedParamsforSigning = keys
            .sort()
            .map((keyName) => {
            return `&${keyName}=${returnParams[keyName]
                .toString()
                .replace(/(&|=)/gi, '_')}`;
        }, [])
            .join('');
        if (this.signature.algorithm === types_1.AlgorithmTypes.md5hash) {
            returnParams.sig = (0, crypto_1.createHash)('md5')
                .update(stringifiedParamsforSigning + this.signature.secret)
                .digest('hex');
        }
        if (this.signature.algorithm === types_1.AlgorithmTypes.md5hmac) {
            returnParams.sig = (0, crypto_1.createHmac)('md5', this.signature.secret)
                .update(stringifiedParamsforSigning)
                .digest('hex');
        }
        if (this.signature.algorithm === types_1.AlgorithmTypes.sha1hmac) {
            returnParams.sig = (0, crypto_1.createHmac)('sha1', this.signature.secret)
                .update(stringifiedParamsforSigning)
                .digest('hex');
        }
        if (this.signature.algorithm === types_1.AlgorithmTypes.sha256hmac) {
            returnParams.sig = (0, crypto_1.createHmac)('sha256', this.signature.secret)
                .update(stringifiedParamsforSigning)
                .digest('hex');
        }
        if (this.signature.algorithm === types_1.AlgorithmTypes.sha512hmac) {
            returnParams.sig = (0, crypto_1.createHmac)('sha512', this.signature.secret)
                .update(stringifiedParamsforSigning)
                .digest('hex');
        }
        return returnParams;
    };
}
exports.Auth = Auth;
//# sourceMappingURL=auth.js.map